## 设计信号处理函数

一般而言，将信号处理函数设计的越简单越好。常见设计方案如下：

+ 信号处理函数设置全局标志性变量并退出。主程序对此标志进行周期性检查
+ 信号处理函数执行某种类型的清理动作，接着终止进程或使用非本地跳转将栈解开并将控制返回到主程序中的预定位置

### 信号的非队列化处理

在执行某信号的处理函数时会阻塞同类信号的传递 。如果在执行处理函数时，再次产生同类信号，那么会阻塞该信号并在处理函数返回之后再进行传递。如果在处理函数执行期间，产生多次同类信号，那么仍然会将其阻塞，但处理函数返回后只会传递一次。

信号的这种阻塞去重方式无疑将影响对信号处理函数的设计。首先，无法对信号产出次数进行可靠计数。其次，在为信号处理函数编码时可能需要考虑处理同类信号多次产生的情况。

### 可重入函数和异步信号安全函数

在信号处理函数中，并非所有系统调用以及库函数均可予以安全调用。

+ 可重入和非可重入函数

  可重入：如果同一进程的多条线程可以同时安全的调用某一函数，那么该函数是可重入的。即，无论其他线程如何调用该函数，函数均可产生预期结果。

  不可重入：更新全局变量或静态数据结构的函数是不可重入的。如果对函数的两个调用同时试图更新同一全局变量，那么二者可能会相互干扰并产生不正确的结果。

  在C语言标准库函数中，这种可能性非常普遍。例如，malloc()和free()就维护一个针对已释放的内存块的链表，用于从堆中重新分配内存。如果主程序在调用malloc期间为一个同样调用malloc的信号处理函数所中断，那么该链表可能会遭到破坏。因此，malloc函数和使用了malloc的库函数都是不可重入的。

  studio函数库成员printf()，它们会为缓冲区I/O更新内部数据结构，所以，在信号处理函数中使用了printf()，主程序又在调用printf()时抄到了信号处理函数的中断，那么可能导致程序崩溃或数据损坏。

  > 在信号处理函数demo中使用printf()是为了更加直观的显示。但是真正的开发中应避免这些非异步信号安全函数

+ 标准的异步信号安全函数

  如果某一个函数是可重入的，又或者信号处理函数无法将其中断，那么称该函数是异步信号安全的。如

  ```c++
  getpid();
  stat();
  chmod();
  ...
  ```

编写信号处理函数有如下两种选择：

+ 确保信号处理函数是可重入的，且只调用异步信号安全的函数
+ 当主程序更新全局变量，信号处理函数可能更新全局变量时，阻塞信号的传递

> 如果使用同一信号处理函数处理多个不同信号，又或者在调用sigaction()时设置了SA_NODEFER标志，那么信号处理函数就有可能中断自己，因此，如果信号处理器函数更新了全局变量，即便主程序不使用这些变量，那么它们依然是不可重入的。（类似于多线程对未加锁的全局变量操作）
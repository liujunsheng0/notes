## 概述

信号是事件发生时对进程的通知机制，进程会采取某些措施来响应信号。

一个进程能够想另一个进程发送信号，信号的这一用法可作为一种同步技术， 是进程间通信的原始方式。进程也可以向自身发送信号，发往进程的信号通常都源于内核。

引发内核为进程产生信号的各类事件如下：

+ 硬件发生异常

  硬件检测到错误条件并通知内核，再由内核发送相应信号给相关进程。硬件异常的例子包括执行一条异常的机器语言指令，如被0除，引用了无法访问的内存区域

+ 用户键入了能够产生信号的终端特殊字符。如中断字符control+ c，暂停字符control+ z

+ 发生了软件事件

  如定时器到期，进程执行的CPU时间超限，进程的某个子进程退出等

针对每个信号，都定义了一个唯一的整数，从1开始顺序展开。

```c++
#include <signal.h>
```

中以SIGxxxx形式的符号对这些整数做了定义。每个信号的实际编号随系统不同而不同。

信号分类：

+ 用于内核向进程通知事件，构成标准信号**，Linux中标准信号范围[1,31]**
+ 实时信号

通常，一旦内核停下来调度进程执行，该进程的等待信号会马上送达，如果进程正在执行，则会立即传递信号。有时需要确保一段代码的执行不受传递来的信号中断，为了做到这一点，可以将信号添加到进程的信号掩码中，会阻塞指定信号的到达，该信号将保持等待状态，直至稍后对其解除阻塞。

信号到达后，进程根据信号可执行的默认操作：

+ 忽略信号，内核之间丢弃信号
+ 终止进程，进程异常终止，如kill 某个进程
+ 产生核心转储文件，同时进程终止
+ 暂停进程的执行
+ 在暂停进程的执行后，恢复进程的执行

除了根据特定信号而采取默认行为外，程序也能改变信号到达时的响应行为。也将此称之为对信号的处置设置。程序可用将对信号的处置设置如下：

+ 采取默认行为
+ 忽略信号
+ 执行信号处理器程序，编写的函数，为了响应传递来的信号而执行适当任务。

## 信号类型

| 信号名称       | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| SIGABRT        | 进程调用abort()函数时，系统向进程发送该信号                  |
| SIGALRM        | 调用alarm()或setitimer()而设置的定时器，到期后，产生该信号   |
| SIGBUS         | 发生了某种内存访问错误                                       |
| SIGCHLD/SIGCLD | 父进程的某一子进程停止/恢复/终止时，向父进程发送该信号       |
| SIGCONT        | 恢复已经暂停运行的进程，如果进程正在运行，忽略该信号         |
| SIGEMT         | 标识依赖于实现的硬件错误                                     |
| SIGFPE         | 特定类型的算数错误，如除以0                                  |
| SIGHUP         | 当终端断开时，发送该信号给终端控制进程。还可用于守护进程，如init，httpd，守护进程收到该信号时重新进行初始化并重读配置文件 |
| SIGILL         | 进程试图执行非法的机器语言指令，系统向进程发送该信号         |
| SIGINFO/SIGPWR | BSD系统中，输入control-T可产生该信号，用户获取前台进程组的状态信息 |
| SIGINT         | 用户输入终端终端字符(Control + C)时，终端驱动程序将发送信号给前台进程 |
| SIGIO          | 利用fcntl()系统调用时，打开的特定类型的文件描述符（如终端，套接字）发生I/O事件时产生该信号 |
| SIGKILL        | 必杀信号，处理程序无法将其阻塞，忽略，捕获，所以总能终止进程 |
| SIGPWR         | 电源故障信号                                                 |
| SIGQUIT        | 用户在键盘上输入退出字符(Control + \)时，内核将信号发往前台进程组，默认情况下，信号终止进程，并生成可用于调试的核心转储文件。进程如果陷入无限循环或无影响时，使用该信号就很合适。 |
| SIGSEGV        | 当应用进程对内存的引用无效时，就会产生该信号。如引用的页不存在，进程更新只读内存，在用户态访问内核的不分内存等 |
| SIGSTOP        | 停止进程                                                     |
| SIGSYS         | 进程发起的系统调用有误                                       |
| SIGTERM        | 用来终止进程的标准信号，也是kill，killall命令所使用的默认信号。精心设计的程序应当为该信号设置处理器程序，以便于能预先清除临时文件和释放资源 |
| SIGTSTP        | 作业控制的停止信号，当用户在键盘上输入挂起字符（control +z）时，将引发该信号给前台进程组，使其停止运行 |
| SIGTTIN        | 作业控制shell运行时，若后台进程组试图对终端进行read()操作，终端驱动程序则向该进程组发送此信号。该信号默认将停止进程 |
| SIGTTOU        | 后台作业的终端输出                                           |
| SIGXCPU        | 当进程的CPU时间超出对应的资源限制时，发送此信号给进程        |
|                |                                                              |

## 改变信号处理方式：singal()

```c++
// 系统调用singal()是设置信号处置的原始API, 不同UNIX的实现存在差异, 可移植性较差
// 系统调用singaction()提供了signal()不具备的功能, 是建立信号处理器的首选API
#include <signal.h>
void (*singal(int sig, void(*)handler(int)))(int);
// 返回之前的信号处置, 函数指针, 指向的是一个带有整型参数且无返回值的函数, 失败返回SIG_ERR
// sig: 希望修改的信号编号
// handler: 标识信号抵达时所调用的函数地址, 该函数无返回值, 并接收一个整型参数
// void handler(int sig) { /* code for handler */ }

int main() {
    void (*old_handler)(int);
    old_handler = singal(SIGINT, new_handler);
    if (old_handler == SIG_ERR) {
        exit(-1);
    }
    // do something, 在此期间, 如果信号SIGINT来了, 新的处置函数会处理该信号
    if (singal(SIGINT, old_headler) == SIG_ERR) {
        exit(-1);
    }
}
```

singaction()的优势

+ 允许在获取信号处置函数的同时无需将其改变
+ 设置各种属性对调用信号处理器函数时的行为施以更加精准的控制
+ 可移植性更加

```c++
#include <signal.h>
int singaction(int sig, const struct sigaction *act, struct sigaction *oldact);
return 0 on success, or -1 on error
// sig 想要获取或改变的信号编号, 不能是SIGKILL和SIGSTOP

struct sigaction {
	void (*sa_handler)(int);
	sigset_t sa_mask;
	int sa_flags;
	void (*sa_restorer)(void);
}
```



## 信号捕捉器

信号处理器程序（信号捕捉器）是指定指定信号传递给进城时将会调用的一个函数。

调用信号处理器程序，可能会随时打断主程序流程，**"内核代表进程来调用处理器程序**"，当处理器返回时，主程序会在处理器打断的位置恢复执行。执行流程如下图

![](https://github.com/liujunsheng0/notes/blob/master/resource/linux/linux%20programming%20interface/singal_handle_process.png?raw=true)

```c++
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

static void sig_handler(int sig) {
    printf("Ouch!\n");              /* Unsafe */
}

void test_signal_handler() {
    // 重设置了SIGINT的信号处理函数, 收到此信号时, 调用
    // SIGINT:终端输入Control + C时, 终端产生此信号
    void (*old_handler)(int);
    old_handler = signal(SIGINT, sig_handler);
    if(old_handler == SIG_ERR) {
        printf("error\n");
        return;
    }
    int times = 10;
    for(int j = 0; j < times; j++) {
        printf("j = %d\n", j);
        sleep(5);  // 输入Control + C时, 终止了sleep
    }
    // 将SIGINT信号处理器回复为默认处理器
    printf("SIGINT TO DEFAULT");
    if (signal(SIGINT, old_handler) == SIG_ERR){
        printf("error\n");
    }
}
```

## kill

与shell的kill命令相似，一个进程能使用kill()系统调用向另一个进程发送信号。

```c++
#include <singal.h>
int kill(pid_t pid, int sig);
return 0 on success, or -1 on error
// pid 进程号
// sig 指定了要发送的信号量
// 如果进程无权发送信号给所请求的pid, 则调用失败, 将errno置为EPERM.
// 若pid所指为一系列进程, 只要其中一个发送成功, 则kill调用成功
```

pid：

+ pid > 0

  发送信号给由pid指定的进程

+ pid = 0

  发信号给与调用进程同组的每个进程，包括调用进程自身。

+ pid = -1

  信号发送范围：调用进程有权将信号发往每个目标进程，除去init和调用进程自身

+ pid < -1

  会向组ID等于该pid绝对值的进程组内所有下属进程发送信号

## 检查进程的存在

kill()系统调用另一个重要的功能，若将sid指定为0（即空信号），则无信号发送。kill()仅会执行错误检查，查看是否可以向目标进程发送信号。这也就意味着可以使用空信号来检测指定pid的进程是否存在。

若发送空信号失败，且errno为ESRCH，则表明进程不存在

若调用失败，且errno为EPERM（表示进程存在，但是无权限发送）或者调用成功（有权向进程发送信号），则表示进程存在。

> 还可以检查/proc/PID目录是否存在来检查进程是否存在

## 发送信号的其他方式

```c++
#include <signal.h>
int raise(int sig); return 0 on success, or 非0 on error
// 单线程程序中等于 kill(getpid(), sig)
// 支持线程的系统等于 phread_kill(phread_self(), sig)
```

## 显示信号描述

每个信号都有一串与之相关的可打印说明。位于数组sys_siglist中，取数据时，推荐使用strsignal()函数。

```c++
#define _GNU_SOURCE
#include <string.h>
char *strsignal(int sig); return pointer to signal description string
// 显示信号描述时会使用本地语言
```

## 信号掩码

内核会为每个进程维护一个信号掩码，即一组信号，并将阻塞其针对该进程的传递。如果将遭阻塞的信号发送给某进程，那么对该信号的传递将延后，直至从进程掩码中移除该信号，从而接触阻塞为止。(信号掩码属于线程属性，在多线程进程中，每个进程都应独立维护其信号掩码)

向信号掩码添加信号

```c++
#include<singal.h>
// 获取和修改新词的信号掩码
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
return 0 on success, or -1 on error
// how 指定了函数给信号掩码带来的变化
// set 信号集
// 若oldset不为空, 返回之前的信号掩码
// 如果set为空, oldset不为空, 则为获取信号掩码
```

how

+ `SIG_BLOCK`

  将set指向信号集内的指定信号添加到信号掩码中

+ `SIG_UNBLOCK`

  将set指向即中的信号从信号掩码中移除

+ `SIG_SETMASK`

  将set指向的信号集赋给信号掩码

## 处于等待的状态的信号

如果某进程接受了一个进程正在阻塞的信号，那么该信号将添加到进程的**等待信号集**中。当解除对该信号的阻塞后，会将该信号传递给此进程。

> 等待信号集只是一个掩码，仅表明一个信号是否发生，未表明发生次数

```c++
#include <signal.h>
// 获取处于等待的信号
int sigpending(sigset_t *set);
return 0 on success, or -1 on error
```

## 不对信号进行排队处理

等待信号集只是一个掩码，仅表明一个信号是否发生，而未表明其发生的次数。换言之，如果同一信号在阻塞状态下产生多次，那么会将信号记录在等待信号集中，并在解除阻塞后仅传递一次。
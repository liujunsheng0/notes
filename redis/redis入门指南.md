[官方文档](http://redisdoc.com/index.html)

[redis](http://redisdoc.com/index.html)：字典结构的存储服务器。

key：键名

value：键值

redis 是一个使用 C 语言写成的，开源的 key-value 数据库。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。

著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

**NOTICE**

> + 所有redis命令都是原子操作
> + redis中的类型不支持嵌套，每个元素都只能是字符串类型



# 可执行文件

| redis-server    | redis服务器（启动redis服务） |
| --------------- | ---------------------------- |
| redis-cli       | redis命令行客户端            |
| redis-benchmark | redis性能测试工具            |
| redis-check-aof | AOF文件修复工具              |
| redis-check-dum | RDB文件检测工具              |
| redis-sentinel  | sentinel（哨兵）服务         |



# 配置

配置文件路径

```bash
/etc/init.d/redis-server

# 配置redis随系统启动
update-rc.d redis-server defaults
```

参数	

| 配置名           | 值                              | 说明                                                         |
| ---------------- | ------------------------------- | ------------------------------------------------------------ |
| daemonize        | yes                             | 使redis以守护进程模式运行                                    |
| pidfile          | /var/run/redis/redis-server.pid | 设置redis的PID文件位置                                       |
| port             | 端口，默认为6379                | 设置redis监听的端口号                                        |
| dir              | /var/lib/redis                  | 设置持久化文件存放位置                                       |
| dbfilename       | dump.rdb                        | 快照文件名                                                   |
| databases        | 16                              | 默认的数据库数量                                             |
| maxmemory        | N bytes                         | 限制redis最大可用内存大小（单位是字节）                      |
| maxmemory-policy | volatile-ttl                    | 内存超过maxmemory后使用maxmemory-policy制定的策略来删除不需要的键，直至占用内存小于maxmemory |
| appendonly       | yes/no                          | 开启AOF持久化，默认不不开启                                  |
| appendfilename   | appendonly.aof                  | AOF持久化文件名                                              |
| host             | 默认为0.0.0.0                   | ip                                                           |
| requirepass      |                                 | 登录密码，默认无                                             |
| slaveof          |                                 | 配置主数据库                                                 |

maxmemory

当设置了redis可用最大空间时，redis不会共享对象，因为对于每一个键值需要使用一个redisObject对象来记录其LRU信息。

maxmemory-policy可选值

| 规则            | 说明                                              |
| --------------- | ------------------------------------------------- |
| volatile-lru    | 使用LRU算法删除一个键，只对设置了过期时间的键生效 |
| allkeys-lru     | 使用LRU算法删除一个键                             |
| volatile-random | 随机删除一个键，只对设置了过期时间的键生效        |
| allkeys-radom   | 随机删除一个键                                    |
| volatile-ttl    | 删除过期时间最近的一个键                          |
| noevction       | 不删除键，返回错误                                |



# 多数据库

redis提供了多个多个用来存储数据的字典。客户端可以指定存在哪个字典中。

每个数据库都是以一个从0开始的递增数字命名，默认支持16个数据库。可通过databases来修改这一参数。默认连接名称为0的数据库。

```bash
# 切换数据库
select 0/1/2/3...
```

> redis不支持自定义数据库名
>
> redis不支持为每个数据库设置不同的访问密码
>
> redis的不同数据库更像命名空间，不适合存储不同应用程序的数据
>
> 一个空的redis服务大概占用的内存为1MB左右



# 命令

**Notice**

+ redis命令不区分大小写，键名区分大小写

##　 获取符合规则的键名列表

### KEYS

```bash
KEYS PATTERN
```

通用符规则

| ?    | 匹配任意一个字符                               |
| ---- | ---------------------------------------------- |
| *    | 匹配任意个字符                                 |
| []   | 匹配括号间的任一字符，可以使用-指定范围如[a-d] |
| \x   | 用于转义字符，如需要匹配?，需要使用\?          |

> KEYS命令会遍历所有的键，键较多时影响性能，不建议在生产环境中使用

### SCAN

```
SCAN  命令用于迭代当前数据库中的数据库键。
SSCAN 命令用于迭代集合键中的元素。
HSCAN 命令用于迭代哈希键中的键值对。
ZSCAN 命令用于迭代有序集合中的元素（包括元素成员和元素分值）
```

以上列出的四个命令都支持增量式迭代， 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 [*KEYS*](http://doc.redisfans.com/key/keys.html#keys)命令、 [*SMEMBERS*](http://doc.redisfans.com/set/smembers.html#smembers) 命令带来的问题 —— 当 [*KEYS*](http://doc.redisfans.com/key/keys.html#keys) 命令被用于处理一个大的数据库时， 又或者 [*SMEMBERS*](http://doc.redisfans.com/set/smembers.html#smembers) 命令被用于处理一个大的集合键时， 它们可能会阻塞服务器达数秒之久。

不过， 增量式迭代命令也不是没有缺点的： 举个例子， 使用 [*SMEMBERS*](http://doc.redisfans.com/set/smembers.html#smembers) 命令可以返回集合键当前包含的所有元素， 但是对于 [*SCAN*](http://doc.redisfans.com/key/scan.html#scan)这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 （offer limited guarantees about the returned elements）。

```bash
SCAN cursor [MATCH pattern] [COUNT count]
count    指定返回的最大成员数量, 默认为10
pattern  指定key的模式
```

SCAN 命令是一个基于游标的迭代器（cursor based iterator）： SCAN命令每次被调用之后， 都会向用户返回一个新的游标， 用户在下次迭代时需要使用这个新游标作为 SCAN 命令的游标参数， 以此来延续之前的迭代过程。当 SCAN 命令的游标参数被设置为 0 时， 服务器将开始一次新的迭代， 而当服务器向用户返回值为 0 的游标时， 表示迭代已结束。

```bash
# 第一次迭代使用 `0` 作为游标， 表示开始一次新的迭代。
redis 127.0.0.1:6379> scan 0
1) "17"
2)  1) "key:12"
    2) "key:8"
    3) "key:4"
# 第二次迭代使用的是第一次迭代时返回的游标， 也即是命令回复第一个元素的值 —— `17`
redis 127.0.0.1:6379> scan 17
1) "0"
2) 1) "key:5"
   2) "key:18"
   3) "key:0"
```

从上面的示例可以看到， `SCAN` 命令的回复是一个包含两个元素的数组， 第一个数组元素是用于进行下一次迭代的新游标， 而第二个数组元素则是一个数组， 这个数组中包含了所有被迭代的元素。

在第二次调用 `SCAN` 命令时， 命令返回了游标 `0` ， 这表示迭代已经结束， 整个数据集（collection）已经被完整遍历过了。

以 `0` 作为游标开始一次新的迭代， 一直调用 `SCAN` 命令， 直到命令返回游标 `0` ， 我们称这个过程为一次**完整遍历**（full iteration）。

​		`SCAN` 命令， 以及其他增量式迭代命令， 在进行完整遍历的情况下可以为用户带来以下保证： **从完整遍历开始直到完整遍历结束期间， 一直存在于数据集内的所有元素都会被完整遍历返回；** 这意味着， 如果有一个元素， 它从遍历开始直到遍历结束期间都存在于被遍历的数据集当中， 那么 `SCAN` 命令总会在某次迭代中将这个元素返回给用户。

然而因为增量式命令仅仅使用游标来记录迭代状态， 所以这些命令带有**以下缺点**：

- 同一个元素可能会被返回多次。 处理重复元素的工作交由应用程序负责， 比如说， 可以考虑将迭代返回的元素仅仅用于可以安全地重复执行多次的操作上。
- **如果一个元素是在迭代过程中被添加到数据集的， 又或者是在迭代过程中从数据集中被删除的， 那么这个元素可能会被返回， 也可能不会， 这是未定义的（undefined）。**

Notice

+ 并发执行多个迭代

  在同一时间， 可以有任意多个客户端对同一数据集进行迭代， 客户端每次执行迭代都需要传入一个游标， 并在迭代执行之后获得一个新的游标， 而这个游标就包含了迭代的所有状态， 因此， 服务器无须为迭代记录任何状态。

+ 中途停止迭代

  因为迭代的所有状态都保存在游标里面， 而服务器无须为迭代保存任何状态， 所以客户端可以在中途停止一个迭代， 而无须对服务器进行任何通知。

  即使有任意数量的迭代在中途停止， 也不会产生任何问题。

+ 使用错误的游标进行增量式迭代

  使用间断的（broken）、负数、超出范围或者其他非正常的游标来执行增量式迭代并不会造成服务器崩溃， 但可能会让命令产生未定义的行为。

  未定义行为指的是， 增量式命令对返回值所做的保证可能会不再为真。

  **只有两种游标是合法的：**

  1. 在开始一个新的迭代时， 游标必须为 `0` 
  2. 增量式迭代命令在执行之后返回的， 用于延续（continue）迭代过程的游标

+ 迭代终结的保证

  增量式迭代命令所使用的算法只保证在数据集的大小有界（bounded）的情况下， 迭代才会停止， 换句话说， 如果被迭代数据集的大小不断地增长的话， 增量式迭代命令可能永远也无法完成一次完整迭代。

  从直觉上可以看出， 当一个数据集不断地变大时， 想要访问这个数据集中的所有元素就需要做越来越多的工作， 能否结束一个迭代取决于用户执行迭代的速度是否比数据集增长的速度更快。



## 判断一个键是否存在

```bash
EXISTS key
# return 1 if exist else 0
```

## 删除键

```bash
DEL key [key...]
# return number of delete

DEL key1 key2 key3

# 删除以user开头的键
redis-cli KEYS "user*" | xargs redis-cli DEL 
```

> del 不支持通配符，可以结合管道批量删除

## 键值的类型

```bash
type key
```

+ string
+ hash（散列类型）
+ list（列表类型）
+ set（集合类型）
+ zset（有序集合类型）

## string

一个字符传类型键值允许存储数据的最大容量为521MB

```bash
# 设置键名-键值 
SET key value

# 获取, 如果不存在返回nil
GET key

# 递增数字, 键值为整数时, 让当前键递增, 返回递增后的值; 如果不存在时会默认键值为0, 所以返回1
# 当键值不为整数时, redis会提示错误（浮点数也会提示错误）
# incr = increment
INCR key

# 与INCR类似， 只不过可通过increment参数指定指定一次新增的值
# INCY key == INCRBY key 1
INCRBY key increment

# decrement 递减, 与INCR相反
DECR key
DECRBY key decrement

# 向尾部追加值，如果key不存在相当于SET key value
APPEND key value

# 获取字符串长度
STRLEN key

# 同时获取/设置多个键值
MGET key [key...]
MSET key value [key value...]

# 位操作
# 获取字符串指定bit位置的值(0/1), 如果越界/key不存在返回0
GETBIT key offset
# 设置指定key的offset位的值, 如果offset越界/key不存在补全0
SETBIT key offset value
# 统计二进制中1的个数，start：字节位置, end：结束位置（包含）
BITCOUNT key [start] [end]
# 多个key进行位运算, 结果存储在destkey, operation可选值为AND OR XOR NOT
BITOP operation destkey key [key...]
#　如set a bar，ascii码为 98，97,114
#             b         a          f
# 二进制： 0110 0010 0110 0001  0111 0010
# index:  0123 4567 89...
```

## hash（散列）

redis采用字典结构以键值对的形式存储数据，而散列类型的键值也是一种字典结构，其存储了字段和字段值的映射，**但字段值只能是字符串，不能是其他类型。**也就是说散列类型不支持类型嵌套。一个散列类型键可以包含`2^32-1`个字段

```bash
# 不区分插入和更新操作，插入操作返回1，更新操作返回0
HSET key fiedl value
# 获取值
HGET key field
HMSET key field value [field value...]
HMGET key field [field...]
# 获取全部的field，返回结果为字段和字段值组成的列表
HGETALL key

# 判断字段是否存在，存在返回1，不存在返回0
HEXISTS key field

# 当字段不存在时赋值，NX = IF NOT EXIST
HSETNX key field value

# 增加数字, 用法通INCRBY
HINCRBY key field increment

# 删除
HDEL key field [field...]

# 只获取字段名/字段值
HKEYS key
HVALUE key
# 获取字段数量
HLEN key
```

## list（列表）

存储一个有序的字符串列表。内部实现为双向链表，所以向两端添加元素时间复杂度为O(1)，但是通过索引访问元素较慢。

```bash
# L = LEFT R = RIGHT，向列表两端增加元素，返回增加元素后列表的长度
LPUSH key value [value]
RPUSH key value [value]

# 两端弹出元素
LPOP key
RPOP key

# 获取列表中元素个数，key不存在时返回0
LLEN key

# 获取列表片, [start, stop], 索引从0开始，支持负索引，如-1代表最右边的元素
LRANGE key start stop

# REM=REMOVE，删除列表中前count个值为value的元素，return实际删除的元素个数
# count > 0, 从左开始删除
# count < 0, 从右开始删除
# count = 0，删除所有置为value的元素
LREM key count value

# index支持负索引， 如果越界/key不存在会提示错误
LINDEX key index
LSET key index value

# 删除指定范围之外的元素，保留[start, end]的元素
LTRIM key start end

# 插入元素，如果不存在pivot的话，则不做插入操作，return key的元素个数
LINSERT key BEFORE/AFTER pivot value

# RPOP source -> LPUSH destination
RPOPLPUSH source destination

# 如果list为空，阻塞连接，直到有新元素加入
# 第二个参数是超时时间, 单位是秒，0代表不限制等待时间，超时后返回nil
# 实现优先级队列，如BLPOP k1 k2 k3 0 检测多个key，如果所有键都没有返回则阻塞，
# 如果其中一个键有元素则弹出元素（多个键时按照从左到右的顺序取键中的一个元素，借此特性实现优先级队列）
BLPOP key [key...] timeout
BRPOP key [key...] timeout
```

## set（集合）

```bash
# 新增
SADD key member [member...]
# 删除， SET REMOVE
SREM key member [member...]
# 获取全部
SMEMBERS key
# 判断是否在集合中
SISMEMBER key member
# 集合操作
SDIFF key [key...]  # 差集
SINTER key [key...] # 交集
SUNION key [key...] # 并集
# 获取个数
SCARD key
# 随机获取集合中的count个元素
SRANDMEMBER key count
# 随机弹出一个元素
SPOP key
```

## sorted set（有序集合类型）

在集合的基础上有序集合类型为集合中的每个元素都关联了一个分数。

有序集合是通过散列表和跳跃表实现的

```bash
# 新增元素
ZADD key score member [score member...]

#　获取元素的分数，如果不存在返回nil
ZSCORE key member

# 获得排名在某个范围的元素列表, [start, stop]，支持负索引
# 无WITHSCORES返回[元素1, 元素2...]; 有WITHSCORES会连分数一起返回[元素1, 分数1，元素2, 分数2...]
# ZRANGE 从小到大，ZREVRANGE 从大到小
ZRANGE key start stop [WITHSCORES]
ZREVRANGE key start stop [WITHSCORES]

# 增加某个元素的分数，返回更改后的分数，如果不存在会提示错误
ZINCRBY key member score

# 获取元素个数
ZCARD key
# 获取分数在[min, max]的元素个数
ZCOUNT key min max
# 删除, 返回删除的数量
ZREM key member [member]

# 获取排名，从0开始，不存在返回nil
ZRANK key member
ZREVRANK key member

# 删除分数范围[min, max]的所有元素
ZREMRANGEBYSCORE key min max
```

# 事务

定义：一组命令的集合。

事务同命令一样都是redis的最小执行单位，一个事务中的命令要么都执行，要么都不执行。

原理：先将一个事务的命令发送给redis，然后再让redis依次执行这些命令。

格式：

```bash
$ MULTI         # 告诉redis下面的命令属于同一个事务，暂时不要执行，先保存起来
OK
$ LPUSH list 1
QUEUED          # 命令已经进入等待执行的事务队列中
$ LPUSH list 2
QUEUED          # 命令已经进入等待执行的事务队列中
$ ...
$ EXEC          # 依次执行事务队列中的所有命令
1) (integer) 1  # EXEC的返回值就是这些命令返回值组成的列表，返回值顺序和命令的顺序相同
2) (integer) 2
```

> + redis保证一个事务中的所有命令要么都执行，要么都不执行。如果在发送EXEC命令前客户端断线了，则redis会清空事务队列，事务中的命令都不执行。一旦客户端发送了EXEC命令，所有的命令都会执行，客户端断线也没关系，因为redis中记录了要执行的命令
>
> + redis的事务并没有提供回滚功能

## 错误处理

+ 事务中出现语法错误，如

  ```bash
  $ MULTI
  ok
  $ SET a
  (error) ERR number of arguments for set command
  $ ERRORCOMMAND key
  (error) unknown command ERRORCOMMAND
  $ EXEC
  (error) EXECABORT Transaction discarded because of previous errors.
  ```

  redis会直接返回错误，不会执行命令

+ 运行错误

  命令执行时出现的错误，如用散列类型的命令操作集合类型的键。这种错误在实际执行前是无法发现的，所以在事务里这样的命令是被redis接受并执行的。如果事务里的一条命令出现了错误，事务里其他的命令依然会继续执行（包括出错命令之后的命令）。

  ```bash
  $ MULTI
  ok
  $ SET key value
  QUNUED
  $ SADD key a
  QUNUED
  $ SET key1 value1
  QUNUED
  $ EXEC
  1) OK
  2) (error) WRONGTYPE Operation against a key holding the wrong kind of value 
  3) OK
  ```



# WATCH

WATCH：监控一个或多个键，一旦其中有一个键被修改或删除，之后的事务就不会执行。监控一直持续到EXEC命令。

UNWATCH：取消监控

```bash
$ set key 1
OK
$ watch key
OK
# 事务执行行修改了key的值，所以事务中的set key 3并没有执行，EXEC返回空结果
$ set key 2 
OK
$ MULTI
OK
$ set key 3
QUEUED
$ exec
(nil)
$ get key
"2"

# 利用watch 实现INCR
def INCR(key):
	WATCH key
	value = GET key + 1
	# key的值中途改变的话，事务不会执行
	MULTI
		set key value
	result = EXEC
	return result[0]
```

> WATCH命令只是当被监控的键被修改后阻止之后一个事务的执行，而不能保证其他客户端不修改这一键值。
>
> 执行EXEC命令后会取消对所有键的监控
>
> 如果使用WATCH监测一个拥有过期时间的键，该键时间到期后自动删除并不会被WATCH命令认为该键被改变



# 过期时间

```bash
# 设置key的过期时间，seconds=剩余秒数，到期后redis会自动删除它
EXPIRE key seconds
PEXPIRE key millisecond 
# return 1 if set success，0 if key not exist or set fail

# 返回过期剩余时间
TTL key
# return 
# 	-2: 键不存在
# 	-1: 存在但是无过期时间
#    剩余秒数: 正常

# 取消过期时间的设置
PERSIST key
# RETURN 1 if success，否则返回（键不存在/键本来就是永久的）
```

用处：

+ 实现访问频率限制
+ 缓存



# 发布与订阅（publish/subscribe）

发布者：向指定频道发送消息，所有订阅此频道的订阅者都会接收到此消息

订阅者：订阅一个/多个频道

```bash
# 发布消息
PUBLISH channel message
# 返回接收到这条消息的订阅者数量

# 订阅制定频道的消息，进入订阅状态
SUBSCRIBE channel [channel...]

# 取消订阅指定频道，如果不指定channel，则取消订阅的所有频道
SUBSCRIBE [channel...]

# 订阅符合一定格式的频道，返回订阅的频道数，如果PATTERN重复包含，则会收到两条相同的消息
PSUBSCRIBE PATTERN [PATTERN...]

# 指定退订的规则
PUNSUBSCRIBE PATTERN [PATTERN...]
```

进入订阅状态后的客户端可能收到的回复

+ 消息的类型（subscribe），表示订阅成功的反馈信息

  订阅成功的频道名称

  当前客户端订阅的频道数量

+ 消息的类型（message），表示接收到的信息

  产生消息的频道名称

  消息的内容

+ 消息的类型（unsubscribe），表示成功取消订阅某个频道

  取消订阅的频道名称

  当前客户端订阅频道数量，当订阅数量为0时退出订阅状态

通用符规则

| ?    | 匹配任意一个字符                               |
| ---- | ---------------------------------------------- |
| *    | 匹配任意个字符                                 |
| []   | 匹配括号间的任一字符，可以使用-指定范围如[a-d] |



# 管道

通过管道可以一次性发送多条命令并在执行完成后一次性将结果返回。

当一组命令中都不依赖于之前命令的执行结果时可以将这组命令通过管道发出，进而减少redis通信次数。




# 持久化

RDB：根据指定的规则"定时"将内存中的数据存储在硬盘上

AOF：后者在每次执行命令后将命令本身记录下来

两种持久化方式可以单独使用其中一种,但更多情况下是将二者结合使用

## RDB

RDB方式的持久化是通过快照(snapshotting)完成的，当符合一定条件时redis会自动将内存中的所有数据生成一份副本并存储在硬盘上，这个过程即为“快照”。

redis会在以下几种情况下对数据进行快照：

+ 根据配置规则进行自动快照
+ 用户执行 SAVE或 BGSAVE命令
+ 执行 FLUSHALL命令
+ 执行复制(replication)时 

### 根据配置规则进行自动快照

redis允许用户自定义快照条件，当符合快照条件时，redis会自动执行快照操作。进行快照的条件可以由用户在配置文件中自定义，由两个参数构成：时间窗口M和改动的键的个数N。每当时间M内被更改的键的个数大于等于N时，符合自动快照条件。

可在redis配置文件中预设进行快照的条件，条件之间是或的关系

```bash
save 900 1     # 900秒内有>=1    个键被修改则进行快照
save 300 10    # 300秒内有>=10   个键被修改则进行快照
save 60 10000  # 60 秒内有>=10000个键被修改则进行快照
```

### 用户执行 SAVE或 BGSAVE命令

SAVE：redis同步执行快照，阻塞客户端请求。生产环境中避免使用

BGSAVE：后台异步进行快照，同时还可以响应来自客户端的请求。执行BGSAVE后立即返回ok，如果想知道快照是否完成，可以通过 LASTSAVE命令获取最近一次成功执行快照的时间，返回结果是一个Unix时间戳

> 手动快照时，推荐使用BGSAVE（background save）
>
> 自动快照时使用的策略就是异步快照

### 执行 FLUSHALL命令

当执行 FLUSHALL 命令时，Redis 会清除数据库中的所有数据。

**不论清空数据库的过程是否触发了自动快照条件，只要自动快照条件不为空redis就会执行一次快照操作。**例如，当定义的快照条件为当1秒内修改10 000个键时进行自动快照，而当数据库里只有一个键时，执行FLUSHALL命令也会触发快照，即使这一过程实际上只有一个键被修改了。当没有定义自动快照条件时，执行FLUSHALL则不会进行快照。

### 执行复制(replication)时

当设置了主从模式时,Redis 会在复制初始化时进行自动快照。

###　快照原理

Redis默认会将快照文件存储在Redis当前进程的工作目录中的dump.rdb文件中，可以通过配置dir和dbfilename两个参数分别指定快照文件的存储路径和文件名。

**快照的过程如下**

+ redis使用fork函数复制一份当前进程(父进程)的副本(子进程)
+ 父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件
+ 当子进程写入完所有数据后会用该临时文件替换旧的 RDB 文件,至此一次快照操作完成

​        在执行 fork 的时候操作系统会使用写时复制(copy -on-write)策略，即fork函数发生的一刻父子进程共享同一内存数据，当父进程要更改其中某片数据时(如执行一个写命令)，操作系统会将该片数据复制一份以保证子进程的数据不受影响，所以新的RDB文件存储的是执行fork一刻的内存数据。

​		写时复制策略也保证了在 fork 的时刻虽然看上去生成了两份内存副本，但实际上内存的占用量并不会增加一倍。这就意味着当系统内存只有2 GB，而Redis数据库的内存有1.5 GB时，执行 fork后内存使用量并不会增加到3GB。

​		当进行快照的过程中，如果写入操作较多，造成 fork 前后数据差异较大，是会使得内存使用量显著超过实际数据大小的，因为内存中不仅保存了当前的数据库数据，而且还保存着 fork 时刻的内存数据。进行内存用量估算时很容易忽略这一问题,造成内存用量超限。

​		redis在进行快照的过程中不会修改RDB文件，只有快照结束后才会将旧的文件替换成新的，也就是说任何时候 RDB 文件都是完整的。RDB 文件是经过压缩(可以配置rdbcompression 参数以禁用压缩节省CPU占用)的二进制格式，占用的空间会小于内存中的数据大小，更加利于传输。

​		redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将一个记录1000万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20~30秒。

​		通过RDB方式实现持久化，一旦Redis异常退出,就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。**如果数据相对重要，则可以使用AOF方式进行持久化。**

## AOF

​		当使用redis存储非临时数据时，一般需要打开AOF持久化来降低进程中止导致的数据丢失。AOF可以将redis执行的每一条写命令追加到硬盘文件中，这一过程显然会降低redis 的性能，但是大部分情况下这个影响是可以接受的。

​		默认情况下redis没有开启**AOF(Append Only File)**方式的持久化，可以通过 appendonly参数启用：`appendonly yes`。

​		开启AOF持久化后每执行一条会更改redis中的数据的命令，redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof，可以通过appendfilename参数修改`appendfilename appendonly.aof`

### AOF的实现

**AOF文件以纯文本的形式记录了redis执行的写命令**。每当达到一定条件时redis就会自动重写AOF文件，覆盖掉无用的写命令。

可在配置文件中指定触发条件

```bash
#　当前的AOF文件大小超过上一次重写时的AOF文件大小的百分之多少时会再次进行重写　 
auto-aof-rewrite-percentage 100
# 限制了允许重写的最小AOF文件大小
auto-aof-rewrite-min-size 64mb
```

可以使用BGREWRITEAOF（background rewrite AOF ）手动执行AOF文件重写。

​		虽然每次执行更改数据库内容的操作时，AOF都会将命令记录在AOF文件中，但是事实上由于操作系统的缓存机制，数据并没有真正地写入硬盘，而是进入了系统的硬盘缓存。在默认情况下系统每30秒会执行一次同步操作，以便将硬盘缓存中的内容真正地写入硬盘，在这30秒的过程中如果系统异常退出则会导致硬盘缓存中的数据丢失。一般来讲启用AOF持久化的应用都无法容忍这样的损失，这就需要redis在写入AOF文件后主动要求系统将缓存内容同步到硬盘中。在 Redis 中我们可以通过 appendfsync 参数设置同步的时机

```bash
# always表示每次执行写入都会执行同步,这是最安全也是最慢的方式
appendfsync always

# 每秒执行一次同步操作
appendfsync everysec

# 不主动进行同步操作,而是完全交由操作系统来做(即每30秒一次),这是最快但最不安全的方式（默认）
appendfsync no
```

redis 允许同时开启 AOF 和 RDB，既保证了数据安全又使得进行备份等操作十分容易。此时重新启动Redis后Redis会使用AOF文件来恢复数据，因为AOF方式的持久化可能丢失的数据更少。



#　安全

​		redis的安全设计是在**redis运行在可信环境**这个前提下做出的。

​		在生产环境运行时不能允许外界直接连接到 redis 服务器上，而应该通过应用程序进行中转，运行在可信的环境中是保证redis安全的最重要方法。

​		redis的默认配置会接受来自任何地址发送来的请求，即在任何一个拥有公网IP的服务器上启动 redis 服务器，都可以被外界直接访问到。要更改这一设置，在配置文件中修改bind参数，如只允许本机应用连接Redis，可以将bind参数改成`bind 127.0.0.1`，bind参数只能绑定一个地址，如果想更自由地设置访问规则需要通过防火墙来完成。



# 集群

## 复制

​		redis提供了复制(replication)功能，当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上。

​		在复制的概念中，数据库分为两类，一类是主数据库(master)，另一类是从数据库(slave)。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而**从数据库一般是只读的**，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。

> 默认情况下，从数据库是只读的，如果直接修改从数据库的数据会出现错误，可在从数据库配置文件中设置`slave-read-only no`使从数据库可写，但是从数据的更改不会同步给其他数据库，并且一旦主数据库中更新了对应的数据就会覆盖从数据库中的改动，所以通常的场景下不应该设置从数据库可写，以免导致容易被忽略的潜在应用逻辑错误。

在配置文件中配置主数据库，只需要在从数据库配置文件中做如下修改

```bash
salveof master_ip master_port
```

### 原理

​		当一个从数据库启动后，会向主数据库发送 SYNC 命令。同时主数据库接收到 SYNC命令后会开始在后台保存快照(即RDB持久化的过程)，并将保存快照期间接收到的命令缓存起来。当快照完成后，Redis会将快照文件和所有缓存的命令发送给从数据库。从数据库收到后，会载入快照文件并执行收到的缓存的命令。以上过程称为复制初始化。

​		复制初始化结束后，主数据库每当收到写命令时就会将命令同步给从数据库，从而保证主从数据库数据一致。当主从数据库之间的连接断开重连后，redis 2.6以及之前的版本会重新进行复制初始化，这使得主从数据库断线重连后的数据恢复过程效率很低下，在网络环境不好的时候这一问题尤其明显。redis 2.8版的一个重要改进就是断线重连能够支持有条件的增量数据传输，当从数据库重新连接上主数据库后，主数据库只需要将断线期间执行的命令传送给从数据库，从而大大提高Redis复制的实用性。

> 从数据同步数据时，并不会阻塞请求，可以继续处理客户端发来的命令。

### 图结构

​		从数据库不仅可以接收主数据库的同步数据，自己也可以同时作为主数据库存在，形成类似图的结构。

​	**通过复制可以实现读写分离,以提高服务器的负载能力。**在常见的场景中（如电子商务

网站），读的频率大于写，当单机的redis无法应付大量的读请求时（尤其是较耗资源的请求,如 SORT 命令等）可以通过复制功能建立多个从数据库节点，主数据库只进行写操作，而从数据库负责读操作。这种一主多从的结构很适合读多写少的场景。而当单个的主数据库不能够满足需求时，就需要使用redis 3.0 推出的集群功能。

### 从数据库持久化

​		为了提高性能，可以通过复制功能建立N个从数据库，并在从数据库中启用持久化，同时在主数据库禁用持久化。当从数据库崩溃重启后主数据库会自动将数据同步过来，所以无需担心数据丢失。
​		然而当主数据库崩溃时，手工通过从数据库数据恢复主数据库数据时，需要严格按照以下两步进行。

1. 在从数据库中使用 `SLAVEOF NO ONE`命令将从数据库提升成主数据库继续服务
2. 启动之前崩溃的主数据库，然后将其设置成新的主数据库的从数据库，即可将数据同步回来

### 增量复制

增量复制是基于如下3点实现的。

1. 从数据库会存储主数据库的运行ID(run id)。每个Redis 运行实例均会拥有一个唯一的运行ID，每当实例重启后，就会自动生成一个新的运行ID
2. 在复制同步阶段，主数据库每将一个命令传送给从数据库时，都会同时把该命令存放到一个积压队列(backlog)中，并记录下当前积压队列中存放的命令的偏移量范围
3. 从数据库接收到主数据库传来的命令时，会记录下该命令的偏移量

这3点是实现增量复制的基础。主数据库收到 SYNC命令后,会执行以下判断来决定此次重连是否可以执行增量复制。

1. 主数据库会判断从数据库传送来的运行ID是否和自己的运行ID相同。这一步骤的意义在于确保从数据库之前确实是和自己同步的，以免从数据库拿到错误的数据
2. 判断从数据库最后同步成功的命令偏移量是否在积压队列中，如果在则可以执行增量复制，并将积压队列中相应的命令发送给从数据库

如果此次重连不满足增量复制的条件，主数据库会进行一次全部同步。

​		大部分情况下，增量复制的过程对开发者来说是完全透明的，开发者不需要关心增量复制的具体细节。唯一需要开发者设置的就是积压队列的大小了。

​		积压队列在本质上是一个固定长度的循环队列，默认情况下积压队列的大小为 1 MB，可以通过配置文件的`repl-backlog-size`选项来调整。积压队列越大，其允许主从数据库断线的时间就越长。根据主从数据库之间的网络状态,设置一个合理的积压队列很重要。因为积压队列存储的内容是命令本身，如`SET foo bar`，所以估算积压队列的大小只需要估计主从数据库断线的时间中主数据库可能执行的命令的大小即可。与积压队列相关的另一个配置选项是`repl-backlog-ttl`，即当**所有**从数据库与主数据库断开连接后，经过多久时间可以释放积压队列的内存空间，默认时间是1小时。

## 哨兵

哨兵的作用就是监控Redis系统的运行状况。它的功能包括以下两个。

+ 监控主数据库和从数据库是否正常运行

+ 主数据库出现故障时自动将从数据库转换为主数据库

哨兵是一个独立的进程哨兵工具来实现自动化的系统监控和故障恢复功能。

## 集群

​		即使使用哨兵，此时的redis集群的每个数据库依然存有集群中的所有数据，从而导致**集群的总数据存储量受限于可用存储内存最小的数据库节点**，形成木桶效应。由redis中的所有数据都是基于内存存储，这一问题就尤为突出了，尤其是当使用 redis 做持久化存储服务使用时。

​		对redis进行水平扩容，在旧版redis中通常使用客户端分片来解决这个问题，即启动多个 redis 数据库节点，**由客户端决定每个键交由哪个数据库节点存储**，下次客户端读取该键时直接到该节点读取。这样可以实现将整个数据分布存储在N个数据库节点中，每个节点只存放总数据量的 1/N。但对于需要扩容的场景来说，在客户端分片后，如果想增加更多的节点，就需要对数据进行手工迁移，同时在迁移的过程中为了保证数据的一致性，还需要将集群暂时下线，相对比较复杂。

​		考虑到redis实例非常轻量的特点，可以采用预分片技术(presharding)来在一定程度上避免此问题，具体来说是在节点部署初期，就提前考虑日后的存储规模，建立足够多的实例，初期时数据很少，所以每个节点存储的数据也非常少，但由于节点轻量的特性，数据之外的内存开销并不大，这使得只需要很少的服务器即可运行这些实例。日后存储规模扩大后，所要做的不过是将某些实例迁移到其他服务器上，而不需要对所有数据进行重新分片并进行集群下线和数据迁移了。

​		无论如何，客户端分片终归是有非常多的缺点，比如维护成本高,增加、移除节点较繁琐等。redis 3.0版的一大特性就是支持集群功能。集群的特点在于拥有和单机实例同样的性能，同时**在网络分区后**能够提供一定的可访问性以及对主数据库故障恢复的支持。另外集群支持几乎所有的单机实例支持的命令，对于涉及多键的命令（如MGET），如果每个键都位于同一个节点中，则可以正常支持，否则会提示错误。除此之外集群还有一个限制是只能使用默认的0号数据库，如果执行SELECT切换数据库则会提示错误。

​		哨兵与集群是两个独立的功能，但从特性来看哨兵可以视为集群的子集，当不需要数据分片或者已经在客户端进行分片的场景下哨兵就足够使用了，但如果需要进行水平扩容,则集群是一个非常好的选择。

### 配置

使用集群，只需要将每个数据库节点的`cluster-enabled yes`配置选项打开即可。每个集群中至少需要3个主数据库才能正常运行。

集群会将当前节点记录的集群状态持久化地存储在指定文件中，这个文件默认为当前工作目录下的nodes.conf文件。每个节点对应的文件必须不同，否则会造成启动失败，所以启动节点时要注意最后为每个节点使用不同的工作目录，或者通过cluster-config-file选项修改持久化文件的名称`cluster-config-file nodes.conf`

### 插槽的分配

新的节点加入集群后有两种选择，要么使用 CLUSTER REPLICATE命令复制每个主数据库来以从数据库的形式运行，要么向集群申请分配插槽(slot)来以主数据库的形式运行。在一个集群中，所有的键会被分配给16384个插槽，而每个主数据库会负责处理其中的一部分插槽。

redis 将每个键的键名的有效部分使用CRC16算法计算出散列值，然后取对16384的余数。这样使得每个键都可以分配到16384个插槽中，进而分配到指定的一个节点中处理。

键名的有效部分是指:

+ 如果键名包含"{"符号，且在"{"符号后面存在"}"符号，并且"{"和"}"之间有至少一个字符，则有效部分是指"{"和"}"之间的内容
+ 如果不满足上一条规则,那么整个键名为有效部分

例如，键{user102}:last.name的有效部分为"user102"，如果命令涉及多个键（如MGET），只有当所有键都位于同一个节点时 redis 才能正常支持。利用键的分配规则，可以将所有相关的键的有效部分设置成同样的值使得相关键都能分配到同一个节点以支持多键操作。

插槽的分配分为如下几种情况

+ 插槽之前没有被分配过，现在想分配给指定节点
+ 插槽之前被分配过，现在想移动到指定节点

### 获取与插槽对应的节点

​		当客户端向集群中的任意一个节点发送命令后，该节点会判断相应的键是否在当前节点中，如果键在该节点中，则会像单机实例一样正常处理该命令；如果键不在该节点中，就会返回一个 MOVE 重定向请求，告诉客户端这个键目前由哪个节点负责，然后客户端再将同样的请求向目标节点重新发送一次以获得结果。

​		如果当前节点并不负责要处理的键，redis命令行客户端会进行自动命令重定向。而这一过程正是每个支持集群的客户端应该实现的。然而相比单机实例，集群的命令重定向也增加了命令的请求次数，原先只需要执行一次的命令现在有可能需要依次发向两个节点，算上往返时延，可以说请求重定向对性能还是有些影响的。
​		为了解决这一问题，当发现新的重定向请求时，客户端应该在重新向正确节点发送命令的同时，缓存插槽的路由信息，即记录下当前插槽是由哪个节点负责的。这样每次发起命令时，客户端首先计算相关键是属于哪个插槽，然后根据缓存的路由判断插槽由哪个节点负责。考虑到插槽总数相对较少(16384个)，缓存所有插槽的路由信息后，每次命令将均只发向正确的节点，从而达到和单机实例同样的性能。

### 故障恢复

​		在一个集群中，每个节点都会定期向其他节点发送 PING 命令，并通过有没有收到回复来判断目标节点是否已经下线了。具体来说，集群中的每个节点每隔1秒钟就会随机选择5个节点，然后选择其中最久没有响应的节点发PING命令。如果一定时间内目标节点没有响应回复，则发起 PING 命令的节点会认为目标节点疑似下线(PFAIL)。疑似下线可以与哨兵的主观下线类比，两者都表示某一节点从自身的角度认为目标节点是下线的状态。与哨兵的模式类似，如果要使在整个集群中的所有节点都认为某一节点已经下线，需要一定数量的节点都认为该节点疑似下线才可以，这一过程具体为

+ 一旦节点A认为节点B是疑似下线状态，就会在集群中传播该消息，所有其他节点收到消息后都会记录下这一信息
+ 当集群中的某一节点C收集到半数以上的节点认为B是疑似下线的状态时，就会将B标记为下线(FAIL)，并且向集群中的其他节点传播该消息，从而使得B在整个集群中下线

在集群中，当一个主数据库下线时，就会出现一部分插槽无法写入的问题。

+ 如果该主数据库拥有至少一个从数据库，集群就进行故障恢复操作来将其中一个从数据库转变成主数据库来保证集群的完整
+ 如果一个至少负责一个插槽的主数据库下线且没有相应的从数据库可以进行故障恢复，则整个集群默认会进入下线状态无法继续工作。如果想在这种情况下使集群仍能正常工作，可以修改配置`cluster-require-full-coverage  no`(默认为yes)

# redis的并发竞争问题如何解决

​		redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。redis本身没有锁的概念，redis对于多个客户端连接并不存在竞争，但是在redis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：

1. 客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。
2. 服务器角度，利用setnx实现锁。



# 简拼

| cli   | client command line interface |
| ----- | ----------------------------- |
| redis | remote dictionary server      |
| INCR  | increment 增加，增长          |
| DECR  | decrment 减少                 |
| TTL   | Time To Live                  |
|       |                               |



# 单词

| sentinel     | 哨兵       |
| ------------ | ---------- |
| expire       | 到期       |
| persist      | 坚持，保持 |
| snapshotting | 快照       |
|              |            |



# 常见问题

https://juejin.im/post/5ad6e4066fb9a028d82c4b66

https://zhuanlan.zhihu.com/p/32540678

https://www.cnblogs.com/Survivalist/p/8119891.html
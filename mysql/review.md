SQL（Structure Query Language）

# Problem

## 常见操作

**进入MySQL命令行后：**

- `\G`：打印结果垂直显示
- `\g`：命令结束符
- `\c`：取消当前MySQL命令
- `\q`：退出MySQL连接
- `\s`：显示服务器状态
- `\h`：帮助信息
- `\d`：改变命令结束符，默认为`;`
- `? cmd`：查看cmd帮助文档

##　DDL，DML，DCL

**DDL（Data Definition Languages）语句：**数据定义语言，定义了不同的数据段、数据库、表、列、索引等**数据库对象**。常用关键字主要包括CREATE、DROP、ALTER，TRUNCATE。

**DML（Data Manipulation Language）语句：**数据操纵语句，用于添加、删除、更新和查询数据库记录，检查数据完整性，常用关键字主要包括 INSERT、DELETE、UPDATE 和SELECT 。

**DCL（Data Control Language）语句：**数据控制语句，这些语句定义了数据库、表、字段、用户的访问权限和安全级别。常用关键字主要包括 GRANT、REVOKE 等。

## char、varchar、text的区别

- CHAR为定长字符串，长度为0~255；VARCHAR，TEXT为变长字符串，长度为0~65536

- CHAR和VARCHAR需要指定长度，TEXT不用指定长度

- 检索时，CAHR删除了尾部的空格；VARCHAR，TEXT保留了这些空格

- CHAR是定长的，根据定义的字符串长度分配足够的空间，CHAR会根据需要使用空格进行填充。

  VARCHAR使用额外1或2个字节存储字符串长度。字符串长度小于255字节时，使用1字节存储字符串长度，否则使用2字节存储字符串长度。

  TEXT使用额外的2个字节存储字符串长度

- CHAR、VARCHAR可以设置默认值，TEXT不可以设置默认值

- 查询速度：CHAR > VARCHAR > TEXT

- 适用场景不同，对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。尽量避免使用TEXT，查询时会使用临时表，导致严重的性能开销。



## DROP，TRUNCATE，DELETE的区别

相同点：

1. TRUNCATE.、不带WHERE子句的DELETE、DROP都会删除表内的所有数据
2. DROP、TRUNCATE都是DDL语句，执行后会自动提交

不同点：

1. TRUNCATE、DELETE 只删除表内的数据

   DROP不仅删除表内的数据，还会删除相关的触发器、索引；依赖于该表的存储过程和函数将保留，但会变为invalid状态

2. DELETE是DML

   TRUNCATE、DROP是DDL

3. DELETE会放到rollback segement 中，事务提交后才生效，能回滚，能触发触发器

   TRUNCATE、DROP操作立即生效，原数据不放到 rollback segment 中，不能回滚，不能触发触发器

4. 执行速度，一般来说：DROP > TRUNCATE > DELETE

5. 适用场景

   DELETE，删除部分数据行（注意带上where子句）

   DROP，删除表，相关索引等

   TRUNCATE，保留表结构而将所有数据删除

6. `TRUNCATE TABLE`在功能上与不带 WHERE子句的 DELETE 语句相同，二者均删除表中的全部行。

   `TRUNCATE TABLE` 比 DELETE 速度快，使用的系统和事务日志资源少。

   DELETE每删除一行，会在事务日志中为所删除的每行做记录。

   `TRUNCATE TABLE`通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。

## 触发器

触发器是一段SQL语句，当触发某个事件时，自动执行这些语句。在MySQL数据库中有如下六种触发器：

1. BEFORE INSERT
2. AFTER    INSERT
3. BEFORE UPDATE
4. AFTER    UPDATE
5. BEFORE DELETE
6. AFTER    DELETE

## [MySQL](https://link.jianshu.com/?t=http://lib.csdn.net/base/mysql)**的复制原理以及流程**

# 存储引擎

## InnoDB

+ 默认事务型引擎，最重要最广泛的存储引擎，性能非常优秀

- 数据存储在共享表空间，可以通过配置分开。也就是多个表和索引都存储在一个表空间中，可以通过配置文件改变此配置
- 对主键查询的性能高于其他类型的存储引擎
- 内部做了很多优化，从磁盘读取数据时会自动构建hash索引，插入数据时自动构建插入缓冲区
- 通过一些机制和工具支持真正的热备份
- 支持崩溃后的安全恢复
- 支持行级锁
- 支持外键

## MyISAM

- 拥有全文索引、压缩、空间函数
- 不支持事务和行级锁、不支持崩溃后的安全恢复
- 表存储在两个文件，MYD和MYI
- 设计简单，某些场景下性能很好，例如获取整个表有多少条数据，性能很高。
- 全文索引不是很常用，不如使用外部的ElasticSearch或Lucene

## InnoDB和MyISAM的区别

- InnoDB支持事务，MyISAM不支持；
- InnoDB支持外键，MyISAM不支持；
- InnoDB不支持全文索引，MyISAM支持全文索引；
- InnoDB支持行级锁，MyISAM只支持表锁；
- InnoDB数据存储在共享表空间，MyISAM数据存储在文件中；
- InnoDB支持崩溃后的恢复，MyISAM不支持；

##  InnoDB的特性

1. 插入缓冲
2. 二次写
3. 自适应哈希索引
4. 预读

## MyISAM和InnoDB的 select count(*) 哪个快？

MyISAM更快，因为MyISAM内部维护了一个计数器，可以直接调取。

# 锁

## 锁机制

当多个查询同一时刻进行数据修改时，就会产生并发控制的问题。共享锁和排他锁，就是读锁和写锁。

- 共享锁，不堵塞，多个用户可以同时读一个资源，互不干扰。
- 排他锁，一个写锁会阻塞其他的读锁和写锁，这样可以只允许一个用户进行写入，防止其他用户读取正在写入的资源。

## 锁的粒度

- 表锁，系统开销最小，会锁定整张表，MyIsam使用表锁。
- 行锁，最大程度的支持并发处理，但是也带来了最大的锁开销，InnoDB使用行锁。

# 索引

## 索引，主键，唯一索引，联合索引的区别

+ 一个表只能有一个主键索引，但是可以有多个唯一索引
+ 主键索引一定是唯一索引，唯一索引不是主键索引
+ 主键可以与外键构成参照完整性约束，防止数据不一致
+ 联合索引：将多个列组合在一起创建索引，可以覆盖多个列。（也叫复合索引，组合索引）
+ 外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性、和实现级联操作（基本不用）
+ 全文索引：MySQL自带的全文索引只能用于MyISAM，并且只能对英文进行全文检索 （基本不用）

## MyISAM索引与InnoDB索引的区别

+ InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。
+ InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。
+ MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。
+ InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。

## 使用索引查询一定能提高查询的性能吗？

通过索引查询数据比全表扫描要快，但是也有一定的代价。

索引需要空间来存储，也需要定期维护，每当有记录在表中增减或索引列被修改时，索引本身也会被修改，这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4,5 次的磁盘I/O。因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。所以使用索引查询不一定能提高查询性能。  

# 优化

## 简述项目中优化SQL语句执行效率的方法，从哪些方面，SQL语句性能如何分析

**如何查找查询速度慢的原因**

记录慢查询日志，分析查询日志，不要直接打开慢查询日志进行分析，这样比较浪费时间和精力，可以使用pt-query-digest工具进行分析

**使用show profile**

**使用show status**

show status会返回一些计数器，show global status会查看所有服务器级别的所有计数有时根据这些计数，可以推测出哪些操作代价较高或者消耗时间多

**show processlist**

观察所有处理进程，清除处理时间过长的

**使用explain**

各个字段含义

**优化查询过程中的数据访问**

> 1. 访问数据太多导致查询性能下降
> 2. 确定应用程序是否在检索大量超过需要的数据，可能是太多行或列
> 3. 确认MySQL服务器是否在分析大量不必要的数据行
> 4. 避免犯如下SQL语句错误
> 5. 查询不需要的数据。解决办法：使用limit解决
> 6. 多表关联返回全部列。解决办法：指定列名
> 7. 总是返回全部列。解决办法：避免使用SELECT *
> 8. 重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存
> 9. 是否在扫描额外的记录。解决办法：使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：
>    + 使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果
>    + 改变数据库和表的结构，修改数据表范式
>    + 重写SQL语句，让优化器可以以更优的方式执行查询。

**优化长难的查询语句**

> 1. 一个复杂查询还是多个简单查询
> 2. MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。
> 3. 切分查询
> 4. 将一个大的查询分为多个小的相同的查询
> 5. 一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。
> 6. 分解关联查询，让缓存的效率更高。
> 7. 执行单个查询可以减少锁的竞争。
> 8. 在应用层做关联更容易对数据库进行拆分。
> 9. 查询效率会有大幅提升。
> 10. 较少冗余记录的查询。

**优化特定类型的查询语句**

> 1. count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名)
> 2. MyISAM中，没有任何where条件的count(*)非常快。
> 3. 当有where条件时，MyISAM的count统计不一定比其它引擎快。
> 4. 可以使用explain查询近似值，用近似值替代count(*)
> 5. 增加汇总表
> 6. 使用缓存

**优化关联查询**

> 1. 确定ON或者USING子句中是否有索引。
> 2. 确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。

**优化子查询**

> 1. 用关联查询替代
> 2. 优化GROUP BY和DISTINCT
> 3. 这两种查询据可以使用索引来优化，是最有效的优化方法
> 4. 关联查询中，使用标识列分组的效率更高
> 5. 如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。
> 6. WITH ROLLUP超级聚合，可以挪到应用程序处理

**优化LIMIT分页**

> 1. LIMIT偏移量大的时候，查询效率较低
> 2. 可以记录上次查询的最大ID，下次查询时直接根据该ID来查询

**优化UNION查询**

> UNION ALL的效率高于UNION
>
> UNION ALL，不会合并重复的记录行
>
> UNION，会合并重复行

**优化WHERE子句**

> 解题方法对于此类考题，先说明如何定位低效SQL语句，然后根据SQL语句可能低效的原因做排查，先从索引着手，如果索引没有问题，考虑以上几个方面，数据访问的问题，长难查询句的问题还是一些特定类型优化的问题，逐一回答。

**善用索引，避免全表扫描**

# 参考链接

https://juejin.im/entry/5b57ec015188251aa8292a69

https://juejin.im/post/5cc299ba6fb9a0324d43b1d1
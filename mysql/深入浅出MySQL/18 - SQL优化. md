# 查看SQL执行频率

```mysql
# 默认为SESSION
SHOW [SESSION | GLOBAL] STATUS;
# variable_name  value
# ...
```

**Com_xxx表示每个xxx语句的执行次数**

| variable_nale | value                                                 |
| ------------- | ----------------------------------------------------- |
| Com_select    | 执行SELECT的次数，一次查询加一                        |
| Com_insert    | 执行INSERT的次数，批量插入的INSERT操作，只累加一次    |
| Com_update    | ...                                                   |
| Com_delete    | ...                                                   |
| Com_commit    | 事务提交次数                                          |
| Com_rollback  | 事务回滚次数，如果回滚次数过多，说明sql编写可能有问题 |
|               |                                                       |

以下参数是针对Innodb存储引擎

| variable_nale        | value                 |
| -------------------- | --------------------- |
| Innodb_rows_select   | select 查询返回的行数 |
| Innodb_rows_inserted | 插入的行数            |
| Innodb_rows_updated  | 更新的行数            |
| Innodb_rows_deleted  | 删除的行数            |

| variable_nale | value                                |
| ------------- | ------------------------------------ |
| Connections   | 试图连接服务器的次数                 |
| Uptime        | 服务器工作时间（从开启到现在的秒数） |
| Slow_queries  | 慢查询次数                           |
|               |                                      |

详见[https://www.cnblogs.com/zuxing/articles/7761262.html](https://www.cnblogs.com/zuxing/articles/7761262.html)



# 通过EXPLAIN/DESC分析SQL

```mysql
EXPLAIN(DESC) sql...;
```

```mysql
mysql> EXPLAIN SELECT * FROM test  WHERE v="a" \G
           id: 1
  select_type: SIMPLE
        table: test   # 输出结果集的表
   partitions: NULL   # 分区
         type: ALL    # 找到所需要行的方式
possible_keys: NULL   # 查询时可能用到的索引
          key: NULL   # 实际用到的索引
      key_len: NULL   # 使用到索引字段的长度
          ref: NULL   
         rows: 1      # 扫描行的数量
     filtered: 100.00
        Extra: Using where  # 执行的额外说明
1 row in set, 1 warning (0.00 sec)
```

+ select_type，以下为常见取值

  | SIMPLE   | 简单表，即不用表连接或子查询      |
  | -------- | --------------------------------- |
  | PRIMARY  | 主查询，即外层的查询              |
  | UNION    | UNION中的第二个或者后面的查询语句 |
  | SUBQUERY | 子查询中的第一个SELECT            |

+ type，常见以下取值

  | ALL          | 全表扫描                                                 |
  | ------------ | -------------------------------------------------------- |
  | index        | 索引全扫描                                               |
  | range        | 索引范围扫描                                             |
  | ref          | 使用非唯一索引扫描或唯一索引的前缀扫描                   |
  | eq_ref       | 使用的索引为唯一索引                                     |
  | const/system | 单表中最多有一个匹配行，查询非常快，如主键或唯一索引查询 |
  | NULL         | 不用访问被就等得到结果                                   |



# 通过show profile分析SQL

```mysql
# 查看数据库是否支持show profiles
SELECT @@have_profiling;
# YES
# 查看是否开启profiling
SELECT @@PROFILING
# 1
```

```mysql
SELECT COUNT(*) FROM test;
SHOW PROFILES;
# qurey_id  duration	query
# 26	    0.00072275	SHOW STATUS
# 27	    0.000699	SHOW STATUS
# 28	    0.000181	SELECT COUNT(*) FROM test
SHOW PROFILE FOR QUERY 28;
```



# 索引

​	索引是在MySQL的存储引擎层中实现的。所以每种存储引擎支持的索引可能会有差异。MySQL中常见的索引为以下几种

+ B-Tree索引
+ HASH索引，只有Memory支持
+ Full-text（全文）索引

		MySQL还能对列的前缀进行索引，虽然可以缩短索引文件的大小，但是在排序和分组的时候无法使用。

| 索引      | MyISAM | InnoDB | Memory |
| --------- | ------ | ------ | ------ |
| B-Tree    | √      | √      | √      |
| HASH      |        |        | √      |
| Full-text | √      |        |        |

HASH索引适用于Key-Value查询，不适用于范围查询（<,>等）操作。一般来说，只有=才会用到索引



## 使用索引

B-Tree构造类似二叉树，能根据键值进行快速的查询，通常只需要很少的操作就可以找到相应的行。

> B-Tree中的B不代表二叉树(binary)，而是代表平衡树(balanced)
>
> B-Tree并不是二叉树，而是多叉树
>
> 可利用B-Tree进行关键字、关键字范围、和前缀查询



存在B-Tree索引但是不能使用索引的场景

1. 以%开头的LIKE查询不能够利用B-tree索引

2. 数据类型出现隐式转换，如表中类型为varchar，查询中使用int

3. 复合索引的情况下，查询条件不满足索引最左的原则

4. Mysql估计使用索引比全表扫描慢，如查询电影名中包含"s"的电影

5. 用or分割开的条件，or前条件有索引，or后的列没有索引

   **因为or后面的条件没有索引，那么后面的查询肯定要进行全表扫描，在存在全表扫描的情况下，就没有必要多一次索引扫描增加IO访问。**



## 查看索引使用情况

```mysql
SHOW STATUS LIKE "Handler_read%";
# Handler_read_first	13
# Handler_read_key	3590   # 索引被读取的次数
# Handler_read_last	0
# Handler_read_next	152
# Handler_read_prev	0
# Handler_read_rnd	501
# Handler_read_rnd_next	11340 # 数据文件中读下一行的请求数, 如果该值很高, 意味着查询低效
```



## [聚集和非聚集索引](https://www.cnblogs.com/aspnethot/articles/1504082.html)

+ 聚集索引

  ​	**索引中键值的逻辑顺序决定了表中相应行的物理顺序。**  

  　　聚集索引确定表中数据的物理顺序。聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序（物理顺序唯一），**因此一个表只能包含一个聚集索引**。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。 

  ​	聚集索引对于那些经常要搜索范围值的列特别有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。例如，如果应用程序执行的一个查询经常检索某一日期范围内的记录，则使用聚集索引可以迅速找到包含开始日期的行，然后检索表中所有相邻的行，直到到达结束日期。这样有助于提高此类查询的性能。同样，如果对从表中检索的数据进行排序时经常要用到某一列，则可以将该表在该列上聚集（物理排序），避免每次查询该列时都进行排序，从而节省成本。 

  > 当索引值唯一时，使用聚集索引查找特定的行也很有效率。检索效率比非聚集索引高，但对数据更新影响较大，因为需要移动对应数据的物理位置；
  >
  > 主键是聚集索引
  >
  > 聚集索引一个表只能有一个

+ 非聚集索引

  ​	索引的逻辑顺序与表中相应行的物理存储顺序不同，一个表可以包含多个非聚集索引。即数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置。

  > 非聚集索引检索效率比聚集索引低，但对数据更新影响较小。

**InnoDB索引实现**

​	在InnoDB中，表数据文件本身就是按B+ Tree组织的一个索引结构。聚集索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块

![](https://images.cnblogs.com/cnblogs_com/aspnethot/Pic11.JPG)

​	上图是InnoDB**聚集索引**的数据结构示意图，可以看到叶节点的**data域包含了完整的数据记录**。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），Innodb会按照如下规则进行处理： 

1. 如果一个主键被定义了，那么这个主键就是作为聚集索引 
2. 如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚集索引 
3. 如果没有主键也没有合适的唯一索引，那么innodb内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的**ROWID**，该列的值会随着数据的插入自增

和其他引擎不同的是，Innodb的非聚集索引的叶子节点上存放的是主键，因为记录所在地址并不能保证一定不会变，但主键可以保证。如下图

![](https://images.cnblogs.com/cnblogs_com/aspnethot/Pic10.JPG)



> 唯一索引是给所做的索引增加了唯一性的约束，添加，修改索引列中数据时，不允许出现重复值。它可以是聚集索引，也可以是非聚集的。

## 深入浅出理解聚集和非聚集索引

​	汉语字典的正文本身就是一个聚集索引。比如，我们要查“安”字，就会很自然地翻开字典的前几页，因为“安”的拼音是“an”，而按照拼音排序汉字的字典是以英文字母“a”开头并以“z”结尾的，那么“安”字就自然地排在字典的前部。如果您翻完了所有以“a”开头的部分仍然找不到这个字，那么就说明您的字典中没有这个字；同样的，如果查“张”字，那您也会将您的字典翻到最后部分，因为“张”的拼音是“zhang”。也就是说，**字典的正文部分本身就是一个目录，您不需要再去查其他目录来找到您需要找的内容。我们把这种正文内容本身就是一种按照一定规则排列的目录称为“聚集索引”。**

​	如果您认识某个字，您可以快速地从自动中查到这个字。但您也可能会遇到您不认识的字，不知道它的发音，这时候，您就不能按照刚才的方法找到您要查的字，而需要去根据“偏旁部首”查到您要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。但您结合“部首目录”和“检字表”而查到的字的排序并不是真正的正文的排序方法，比如您查“张”字，我们可以看到在查部首之后的检字表中“张”的页码是672页，检字表中“张”的上面是“驰”字，但页码却是63页，“张”的下面是“弩”字，页面是390页。很显然，这些字并不是真正的分别位于“张”字的上下方，现在您看到的连续的“驰、张、弩”三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到您所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到您所需要的页码。我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引”。

​	每个表只能有一个聚集索引，因为目录只能按照一种方法进行排序。

# SQL优化

## 大批量插入数据

以下几种方式可以关闭InnoDB表的导入方式

1. 因为InnoDB类型表是按照主键顺序保存的，所以导入的数据按照主键顺序排列，可以有效的提高导入效率
2. 导入数据前，执行`SET UNIQUE_CHECKS=0` ，关闭唯一性校验，结束后恢复教研
3. 如果应用为自动提交的方式，建议在导入前执行`SET AUTOCOMMIT=0`，关闭自动提交，导入结束后再打开

## INSERT

1. 一次插入多个值

   ```mysql
   INSERT DELAYED INTO `test`.`test`(`v`) VALUES ('a'), ('b'), ('c');
   ```

2. 如果从不同客户端插入很多行，可以使用INSERT DELAYED语句得到更高的速度。

   INSERT DELAYED INTO，MySQL返回OK状态给客户端。然而并没有将数据插入表，而是存储在内存里面等待排队。当mysql有空余时，再插入。

   优点：提高插入的速度，客户端无需等待太长时间。

   缺点：不能返回自动递增的ID，以及系统崩溃时，MySQL还没有来得及插入数据的话，这些数据将会丢失。

## 表优化

当删除了表的大部分数据或者对包含可变长度的列的表进行了修改，则应使用如下命令进行表优化

```mysql
OPTIMIZE TABLE table_name1, [table_name2...]
# 执行期间, 将会对表进行锁定
# 只对MyISAM, InnoDB, BDB表有效
```

## 表数据类型优化

```mysql
# 使用PROCEDURE ANALYSE对当前表分析, 根据表中数据提出优化建议
SELECT * FROM table_name PROCEDURE ANALYSE();
```

## 通过拆分提高表的访问效率

如果一些列常用，一些列不常用，则可以垂直拆分。这样使得数据行变小，在查询时就会减少IO次数，缺点是联合查表时需要JOIN

## 逆规范化

如移动账单每月都会查询自己的账单，假设用户名和基本信息放一张表里，账单放在另一张表里，而账单表没有存储用户名，所以每次查询时都需要进行表连接（表连接效率较差）。如果在表设计时，账单表里新增一个冗余字段存放用户名，这样在查询时就不用进行表连接，从而提高了查询效率

## 使用中间表提高统计和查询速度

对于数据量较大的表，在其上进行统计查询效率会很低，所以需要考虑统计查询是否会对线上应用产生负面影响。通常在这种情况下可以使用中间表来提高统计查询的效率。

如session表记录了每个客户消费记录，需要统计每个客户每周消费总额，可以创建一个与session一样的表tmp_session，将session中的数据导入tmp_session中，然后在中间表进行统计，这样即提高了查询速度，又不会影响线上应用。



# 正则表达式

正则表达式用来描述或者匹配符合规则的字符串。它的用法和LIKE比较相似，但是它又比LIKE更强大，能够实现一些很特殊的规则匹配。

正则表达式需要使用REGEXP命令，匹配上返回"1"，匹配不上返回"0"，默认不加条件REGEXP相当于LIKE '%%'。在前面加上NOT相当于NOT LIKE。

| 命令    | 说明                                                     |
| ------- | -------------------------------------------------------- |
| ^       | 在字符的开启处进行匹配                                   |
| $       | 在字符的末尾处进行匹配                                   |
| .       | 匹配任何字符（包括回车和新行）                           |
| [….]    | 匹配括号内的任意单个字符                                 |
| [m-n]   | 匹配m到n之间的任意单个字符，例如[0-9],[a-z],[A-Z]        |
| [^..]   | 不能匹配括号内的任意单个字符                             |
| a*      | 匹配0个或多个a,包括空,可以作为占位符使用.                |
| a+      | 匹配一个或多个a,不包括空格                               |
| a?      | 匹配一个或0个a                                           |
| a1\| a2 | 匹配a1或a2                                               |
| a{m}    | 匹配m个a                                                 |
| a{m,}   | 匹配m个或者更多个a                                       |
| a{m,n}  | 匹配m到n个a                                              |
| a{,n}   | 匹配0到n个a                                              |
| (….)    | 将模式元素组成单一元素，例如(do)*意思是匹配0个多或多个do |

```mysql
SELECT * FROM test;
# v
# ab
# ac
# bc
SELECT * FROM test WHERE v REGEXP "^a";      # ab, ac
SELECT * FROM test WHERE v NOT REGEXP "^a";  # bc
SELECT * FROM test WHERE v REGEXP "b.";      # bc
```

